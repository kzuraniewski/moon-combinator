--[[ AUTOGENERATED LIBRARY ]] lib={}lib.CLOCK_SIGNAL='signal-A'lib.MAX_DELAY=60*60*60*24*365;function lib.passSignals(...)local a={...}if#a==0 then out=red;return end;if out==nil then out={}end;for b,c in ipairs(a)do out[c]=red[c]end end;function lib.createTrigger(d)delay=lib.MAX_DELAY;irq=d end;function lib.synchronize()lib.createTrigger(lib.CLOCK_SIGNAL)end;function lib.reset()out={}var={}end

-- desc: value iterator
-- connect a constant combinator with non-zero amount of signals 0-9 and give them values
-- when updating input array it's best to disable and enable the input after updating to ensure refresh
-- TODO: a-z for higher indexes

local MAX_INDEX = 9;
local OUTPUT_SIGNAL = 'signal-V';

function readIndexedValue(index)
	local signalName = 'signal-'..index;
	return red[signalName];
end

function getIndexedValues()
	local parsedArray = {};

	for i = 0, MAX_INDEX, 1 do
		local value = readIndexedValue(i);
		if (value == 0) then break end;
		
		table.insert(parsedArray, value);
	end

	return parsedArray;
end

function hasIndex(array, index)
	return
		type(index) == 'number' and
		index >= 0 and
		index <= #array;
end

function isStateValid(values)
	return
		#values > 0 and
		hasIndex(values, var.lastIndex);
end

function run()
	local values = getIndexedValues();
	if (var.lastIndex == nil) then var.lastIndex = 0 end;

	if not isStateValid(values) then
		lib.reset();
		return;
	end

	local index = (var.lastIndex + 1) % #values; -- indexing from 0 for convenience
	out[OUTPUT_SIGNAL] = values[index + 1];
	var.lastIndex = index;
end

run();
lib.synchronize();
